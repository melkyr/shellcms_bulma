#!/bin/bash
#shellCMS originally forked from BashBlog, github.com/carlesfe/bashblog
# license: GPLv3 (ref: http://www.gnu.org/licenses/)
#shellCMS-specific code, (c) copyright Barry kauler 2017, license GPLv3.
#1708xx major rewrites since fork, including:
# local development, upload with rsync
# posts stored in sub-folders
# large tag_*.html files split into (up to) 5, with newer/older links
# blog or documents mode
#170903 markdown dropped completely. support SeaMonkey Composer WYSIWYG HTML editor.
#170911 rewritten without LOCAL dir, more logical directory hierarchy.
#170915 optional front-page for each category.
#171110 tag_<cat>-<num> max num=9, bug fix drafts.
#180210 tag_* pages, "Older" link was wrong.
#180303 fix multiple href tag and image links same line.
#181004 sometimes <h1> is not at beginning of source.
#200202 optional hit-counter in main index.html page.
#20210830 css now a separate file. ref: main_header.txt
#20210830 cms_footer now an iframe, inserts css0/foot.txt
#20210830 remove variable global_license, as not used.
#20210830 have removed the hit counter.
#20211201 support bluegriffon. 20220520 fix.
#20230423 Fix from commands with option switches issue. Added support for helix/vscode
#20241124 Refactor tags. Refactored create_html_page(). Split blog entries by a global number of posts.
#20250417 Added switches -i and -igum to support TUI

# Displays the help.
usage_func() {
 echo "Usage: ./shellcms path command [folder/filename]"
 echo
 echo "Path:"
 echo "  Relative path to shellCMS installation on local PC"
 echo "  exs: \"www\" \"www/news\""
 echo
 echo "Commands:"
 echo "  post [folder/filename]  Insert a new blog post, or the filename of a draft
                          to continue editing it. ex: post drafts/a-post.htmraw
                          or forced path/name. ex: post admin/new-post.htmraw
                          (latter is for a new post, in document mode only)"
 echo "  edit [-n] [folder/filename] Edit an already published .htmraw file.
                          (NEVER edit manually a .html or .htmraw file)
                          ex: 201709/this-is-an-existing-blog-post.htmraw
                          '-n' to give the file a new name, if title changed"
 echo "  delete [folder/filename] Deletes the post and rebuilds the blog"
 echo "  rebuild                  Regenerates all the pages and posts, 
                          preserving the content of the entries"
 echo "  reset                   Deletes ALL posts. 
                          use with a lot of caution and back up first!"
 echo "  list                    List all posts"
 echo "  tags [-n]               List all tags in alphabetical order
                          use '-n' to sort list by number of posts"
 echo
}
[ ! $1 ] && usage_func && exit

err_exit() {
 echo "ERROR: ${@}"
 exit 1
}

# 1) parse -i / -igum
INTERACTIVE=0
USE_GUM=0
if [[ $1 == "-igum" ]]; then
  INTERACTIVE=1; USE_GUM=1; shift
elif [[ $1 == "-i" ]]; then
  INTERACTIVE=1; USE_GUM=0; shift
fi

if (( INTERACTIVE )); then
  if (( USE_GUM )); then
    command -v gum >/dev/null || { echo "ERROR: gum not installed"; exit 1; }
  else
    command -v dialog >/dev/null || { echo "ERROR: dialog not installed"; exit 1; }
  fi
fi

do_initial_setup(){
PATH0="${1#./}" #get rid of any leading ./
PATHcms="${PATH0/%\//}" #get rid of any trailing /
[ ! -f ${PATHcms}/cms_config/cms_skeleton.txt ] && err_exit "First parameter must be relative path to shellCMS installation. Aborting"
TOPcms="${PATHcms/\/*/}" #exs: www/news becomes www. www becomes www. www/more/news becomes www
BASEcms="$(basename $PATHcms)" #ex: www/news becomes news

path_cms_top="$(ls -1 */cms_config/cms_skeleton.txt | cut -f 1 -d '/' | head -n 1)" #ex: www
[ ! "$path_cms_top" ] && path_cms_top="$(ls -1 */*/cms_config/cms_skeleton.txt | cut -f 1,2 -d '/' | head -n 1)" #ex: www/news

PWD0="$(pwd)"
cd $PATHcms

#check correct installation
ls -1 cms_config/cms_begin.txt cms_config/cms_end.txt cms_config/cms_footer.txt cms_config/cms_header.txt cms_config/config cms_config/excludelist images0 cms_config/cms_skeleton.txt > /dev/null
if [ $? -ne 0 ];then
 echo "In folder '${PATHcms}', one or more of these required files is missing:"
 echo " Files: cms_end.txt cms_footer.txt cms_header.txt config excludelist 
 cms_skeleton.txt. Folder: images0"
 echo "Aborting"
 exit 1
fi

PWD="`pwd`"
num_splits=1; cnt_splits=1 #170829b

#MODE notes
#MODE=blog, sub-folder will be named <year><month>
#MODE=document, sub-folder will be named <tag> (category) -- only allowed one tag per post.

echo -e '2.3\n1.2' | sort -V >/dev/null
if [ $? -ne 0 ];then
 echo "ERROR: you have an old version of 'sort' utility, that does not support '-V'"
 exit
fi

# Global variables
# It is recommended to perform a 'rebuild' after changing any of this in the code

# Config file. Any settings "key=value" written there will override the
# global_variables defaults. Useful to avoid editing shellcms and having to deal
# with merges in VCS
global_config="./cms_config/config"

#20230423 improvement to store more default options when config file not read, order here is important(?)
readonly available_editors=(
    'seamonkey|mozeditor'
    'bluegriffon|bluegriffon'
    'geany|geany -i'
    'code|code -n'
    'hx|hx'
    'vi|vi'
    )

function set_baseline_editor(){
    local editor exec_command
    local OLDIFS=$IFS 
    IFS='|'
    for fields in "${available_editors[@]}"
    do
        read -r editor exec_command <<< "$fields"
        if which $editor >/dev/null; then
            EDITOR=$exec_command
            break
        fi
    done
    IFS=$OLDIFS
}
# Load a baseline for editors
set_baseline_editor
#20230423

EDITOR0="$EDITOR"
}

# This function will load all the variables defined here. They might be overridden
# by the 'global_config' file contents.
global_variables() {
    MODE="document" #170828 values: document, blog
    
    global_software_name="shellCMS_bulma"
    global_software_version="0.1"

    # Site title
    global_title="My site"
    # The typical subtitle for each post
    global_description="A blog about turtles and carrots"
    #url of the site
    global_site_url="http://bkhome.org"
    #The public base URL for shellCMS
    global_cms_url="${global_site_url}/news"

    # Your name
    global_author="John Smith"
    # You can use twitter or facebook or anything for global_author_url
    global_author_url="http://twitter.com/example" 
    # Your email
    global_email="john@smith.com"

    # If you have a Google Analytics ID (UA-XXXXX) and wish to use the standard
    # embedding code, put it on global_analytics
    # If you have custom analytics code (i.e. non-google) or want to use the Universal
    # code, leave global_analytics empty and specify a global_analytics_file
    global_analytics=""
    global_analytics_file=""

    # Leave this empty (i.e. "") if you don't want to use feedburner, 
    # or change it to your own URL
    global_feedburner=""

    # Change this to your username if you want to use twitter for comments
    global_twitter_username=""
    # Set this to false for a Twitter button with share count. The cookieless version
    # is just a link.
    global_twitter_cookieless="true"
    # Default search page, where tweets more than a week old are hidden
    global_twitter_search="twitter"

    # Change this to your disqus username to use disqus for comments
    global_disqus_username=""
    posts_per_page=5

    # Blog generated files
    # index page of blog (it is usually good to use "index.html" here)
    index_file="index.html"
    number_of_index_articles="10"
    # global archive
    archive_index="all_posts.html"
    tags_index="all_tags.html"
    docs_index="all_docs.html"

    # Non blogpost files. Bashblog will ignore these. Useful for static pages and custom content
    # Add them as a bash array, e.g. non_blogpost_files=("news.html" "test.html")
    non_blogpost_files=()

    # feed file (rss in this case)
    blog_feed="feed.rss"
    number_of_feed_articles="10"
    # "cut" blog entry when putting it to index page. Leave blank for full articles in front page
    # i.e. include only up to first '<hr>', or '----' in markup
    cut_do="cut"
    # When cutting, cut also tags? If "no", tags will appear in index page for cut articles
    cut_tags="yes"
    # Regexp matching the HTML line where to do the cut
    # note that slash is regexp separator so you need to prepend it with backslash
    cut_line='<hr ?\/?>'
    
    # personalized header and footer (only if you know what you're doing)
    # DO NOT name them .header.html, .footer.html or they will be overwritten
    header_file="cms_config/cms_header.txt"
    footer_file="cms_config/cms_footer.txt"
    # extra content to add just after we open the <body> tag
    # and before the actual blog content. 
    body_begin_file="cms_config/cms_begin.txt"
    # extra content to add just before we close <body tag (just before </body>)
    body_end_file="cms_config/cms_end.txt"
    
    # HTML files to exclude from index, f.ex. post_exclude=('imprint.html 'aboutme.html')
    html_exclude=()

    # Localization and i18n
    # "Comments?" (used in twitter link after every post)
    template_comments="Comments?"
    # "Read more..." (link under cut article on index page)
    template_read_more="Read more..."
    # "View more posts" (used on bottom of index page as link to archive)
    template_archive="View more posts"
    docs_history="Documentation history" #170828 BK
    # "All posts" (title of archive page)
    template_archive_title="All posts"
    # "All tags"
    template_tags_title="All tags"
    template_docs_title="All documents"
    # "posts" (on "All tags" page, text at the end of each tag line, like "2. Music - 15 posts")
    template_tags_posts="posts"
    template_tags_posts_2_4="posts"  # Some slavic languages use a different plural form for 2-4 items
    template_tags_posts_singular="post"
    # "Posts tagged" (text on a title of a page with index of one tag, like "My Blog - Posts tagged "Music"")
    template_tag_title="Posts tagged"
    # "Tags:" (beginning of line in HTML file with list of all tags for this article)
    template_tags_line_header="Tags:"
    # "Back to the index page" (used on archive page, it is link to blog index)
    template_archive_index_page="Back to the index page"
    # "Tweet" (used as twitter text button for posting to twitter)
    template_twitter_button="Tweet"
    template_twitter_comment="&lt;Type your comment here but please leave the URL so that other people can follow the comments&gt;"
    
    # The locale to use for the dates displayed on screen
    date_format="%B %d, %Y"
    date_locale="C"
    date_inpost="bashblog_timestamp"
    # Don't change these dates
    date_format_full="%a, %d %b %Y %H:%M:%S %z"
    date_format_timestamp="%Y%m%d%H%M.%S"
    date_allposts_header="%B %Y"

    # Perform the post title -> filename conversion
    # Experts only. You may need to tune the locales too
    # Leave empty for no conversion, which is not recommended
    # This default filter respects backwards compatibility
    convert_filename="iconv -f utf-8 -t ascii//translit | sed 's/^-*//' | tr [:upper:] [:lower:] | tr ' ' '-' | tr -dc '[:alnum:]-'"

    #170829 tag_*.html pages may be split...
    older_page_link_msg="Older"
    newer_page_link_msg="Newer"
    
    #permanent buttons, all pages...
    button_permanent_1="sitehome"
    button_permanent_2="contact"
    button_permanent_3=""

    #170830a button messages
    button_sitehome_icon="home24.png"
    button_sitehome_tooltip="Website homepage"
    button_sitehome_url="${global_site_url}/"
    button_sitehome_text="site"
    button_subhome_icon="tech24.png"
    button_subhome_tooltip="Tech homepage"
    button_subhome_url="${global_cms_url}/"
    button_subhome_text="tech"
    button_contact_icon="contact24.png"
    button_contact_tooltip="Send email to site manager"
    button_contact_url="http://somewhere.org/contact/"
    button_contact_text="contact"
    button_history_icon="history24.png"
    button_history_tooltip="Document history"
    button_history_text="history"
    button_tagsindex_icon="index24.png"
    button_tagsindex_tooltip="All documents"
    button_tagsindex_text="index"
    button_tag_icon="tag24.png"
    button_tag_tooltip="Tags"
    button_rss_icon="rss24.png"
    button_rss_tooltip="RSS feed"
    button_rss_text="rss"
    
    #button link to another shellcms installation
    button_cms2_icon="news24.png"
    button_cms2_tooltip="News blog"
    button_cms2_url="${global_site_url}/news"
    button_cms2_text="news"
    
    #search box
    #placement: space-delimited list: "<value1>[ <value2>]". empty, do not display. 
    #allowed values: index post tags all_posts all_docs all_tags
    search_box_pages="index"
    #width of box in pixels:
    search_box_width="50"
    #search engine value (choose one): duckduckgo
    search_box_engine="duckduckgo"
    
    #category-frontpage (ex: shellcms/index.html) has links at the bottom (ref: category_index_func)
    category_frontpage_linkstitle="Documentation"
    
    #was thinking of using an associative array, but this does the job...
    #in index pages that show tag as a header, replace with from here...
    tag2header="shellcms shellCMS
general General
light Traveling Light
linux Puppy, Quirky, Easy Linux, etc"
    
}

#170903 set some config params if mozeditor. seamonkey must not be running.
if [ "$EDITOR" == "mozeditor" ];then
 if [ ! -f /var/local/shellcms-fixed-mozedit-flag ];then #just do it once.
  killall seamonkey
  sleep 0.5
  MOZPREFS="$(find ~/.mozilla -type f -name 'prefs.js' | head -n 1)"
  for aMOZPREF in $MOZPREFS
  do
   sed -i '/CR_creates_new_p/d' $aMOZPREF
   echo 'user_pref("editor.CR_creates_new_p", true);' >> $aMOZPREF
   sed -i '/editor\.prettyprint/d' $aMOZPREF
   echo 'user_pref("editor.prettyprint", true);' >> $aMOZPREF
  done
  touch /var/local/shellcms-fixed-mozedit-flag
 fi
fi

# Check for the validity of some variables
# DO NOT EDIT THIS FUNCTION unless you know what you're doing
global_variables_check() {
    [[ $header_file == .header.html ]] &&
        echo "Please check your configuration. '.header.html' is not a valid value for the setting 'header_file'" &&
        exit
    [[ $footer_file == .footer.html ]] &&
        echo "Please check your configuration. '.footer.html' is not a valid value for the setting 'footer_file'" &&
        exit
}

#create a search box
search_box_func() {
 base_cms_url="${global_cms_url/*\/\//}" #take off http://
 css_style_form="field has-addons"
 css_style_input="input is-small mt-1"
 css_style_button="button is-small mt-1"
 case $search_box_engine in
  google)
   echo "<form class=\"${css_style_form}\" action=\"https://www.google.com/search\" target=\"_blank\" style=\"float:right\">
  <input class=\"${css_style_input}\" type=\"text\" name=\"q\" placeholder=\"search\" style=\"width:${search_box_width}\">
  <input type=\"hidden\" name=\"sitesearch\" value=\"${base_cms_url}\">
  <button class=\"${css_style_button}\" type=\"submit\">Go</button>
</form>"
  ;;
  duckduckgo-official)
   #warning, need to escape those "&", with "\\"
   echo "<iframe src=\"https://duckduckgo.com/search.html?width=${search_box_width}\\&site=${base_cms_url}\\&prefill=Search\" style=\"float:right;overflow:hidden;margin:0;padding:0;width:178px;height:40px;\" frameborder=\"0\"></iframe>"
  ;;
  *) #duckduckgo
   echo "<form action=\"https://duckduckgo.com/\" target=\"_blank\" style=\"float:right\">
  <input type=\"text\" name=\"q\" value=\"search\" style=\"width:${search_box_width}\" maxlength=\"200\">
  <input type=\"hidden\" name=\"sites\" value=\"${base_cms_url}\">
  <button type=\"submit\">Go</button>
</form>"
  ;;
 esac
# echo "<div id=\"contentsearch\" style=\"float:right\">
#<form id=\"searchForm\" name=\"searchForm\" action=\"https://www.google.com/search\" target=\"_blank\">
# <input name=\"q\" type=\"text\" value=\"search\" size=\"${search_box_width}\" maxlength=\"200\" />
# <input name=\"q\" type=\"hidden\" value=\"site:bkhome.org\" />
# <input name=\"submit\" type=\"submit\" value=\"GO\" />
#</form>
#</div>"
}

# Parse a markup file into HTML and return the generated file
markup() {
    #170903 *.htmraw has the post created by the html editor.
    sed '1,/<body>/d';'/<\/body>/Q' ${1} #leave only inside body tags.
}


# Prints the required google analytics code
google_analytics() {
    [[ -z $global_analytics && -z $global_analytics_file ]]  && return

    if [[ -z $global_analytics_file ]]; then
        echo "<script type=\"text/javascript\">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', '${global_analytics}']);
        _gaq.push(['_trackPageview']);

        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

        </script>"
    else
        cat "$global_analytics_file"
    fi
}

# Prints the required code for disqus comments
disqus_body() {
    [[ -z $global_disqus_username ]] && return

    echo '<div id="disqus_thread"></div>
            <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
               var disqus_shortname = '"'$global_disqus_username'"'; // required: replace example with your forum shortname

            /* * * DONT EDIT BELOW THIS LINE * * */
            (function() {
            var dsq = document.createElement("script"); dsq.type = "text/javascript"; dsq.async = true;
            dsq.src = "//" + disqus_shortname + ".disqus.com/embed.js";
            (document.getElementsByTagName("head")[0] || document.getElementsByTagName("body")[0]).appendChild(dsq);
            })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>'
}

# Prints the required code for disqus in the footer
disqus_footer() {
    [[ -z $global_disqus_username ]] && return
    echo '<script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = '"'$global_disqus_username'"'; // required: replace example with your forum shortname

        /* * * DONT EDIT BELOW THIS LINE * * */
        (function () {
        var s = document.createElement("script"); s.async = true;
        s.type = "text/javascript";
        s.src = "//" + disqus_shortname + ".disqus.com/count.js";
        (document.getElementsByTagName("HEAD")[0] || document.getElementsByTagName("BODY")[0]).appendChild(s);
    }());
    </script>'
}

# Reads HTML file from stdin, prints its content to stdout
# Extracts content between specified markers and handles content truncation
get_html_file_content() {
    local start_marker="$1"    # Where to start ("text" or "entry")
    local end_marker="$2"      # Where to stop ("text" or "entry")
    local should_cut="$3"      # "cut" to truncate at <hr /> tag
    
    awk "/<!-- ${start_marker} begin -->/, /<!-- ${end_marker} end -->/{
        # Print content between markers, excluding the markers themselves
        if (!/<!-- ${start_marker} begin -->/ && !/<!-- ${end_marker} end -->/) print
        
        # Handle content truncation if requested
        if (\"${should_cut}\" == \"cut\" && /$cut_line/){
            if (\"${end_marker}\" == \"text\") exit
            # Preserve tags if needed while truncating
            while (getline > 0 && !/<!-- text end -->/) {
                if (\"$cut_tags\" == \"no\" && /^<p>$template_tags_line_header/ ) print 
            }
        }
    }"
}

#Edit an existing .htmraw file.
# Note that if you edit title then filename might also change
#
# $1 	the file to edit
# $2	(optional) edit mode:
#	"keep" to keep old filename
#	leave empty for default behavior (edit only text part and change name)
edit_func() {
    local file1=${1#./}
    local edit_mode="$2"
    local file_sans_ext=${file1%%.*}
    local filename
    local edit_timestamp
    local touch_timestamp
    local tags
    
    validate_file() {
        [ "${file1/*./}" != "htmraw" ] && echo "ERROR: File ${file1} is not .htmraw" && exit -1
        [ ! -f ${file_sans_ext}.htmraw ] && echo "ERROR: File ${file_sans_ext}.htmraw does not exist" && exit -1
    }
    
    get_timestamps() {
        edit_timestamp=$(LC_ALL=C date -r "${file_sans_ext}.html" +"$date_format_full")
        touch_timestamp=$(LC_ALL=C date -r "${file_sans_ext}.html" +"$date_format_timestamp")
    }
    
    process_edit() {
        local subfolder="${file_sans_ext/\/*/}"
        ask_tags_func "${file1}" "$subfolder"
        ${EDITOREXE} ${PWD}/${file1} 2>/dev/null
        format_content "${file1}"
    }
    
    format_content() {
        local file="$1"
        sed -i -e 's%<body>.*<h1>%\n<body>\n<h1>%' "$file"
        sed -i -e 's%<!--RawTags%\n<!--RawTags%' -e 's%</body>%\n</body>%' -e 's%</html>%\n</html>%' "$file"
        
        if ! grep '\-\-RawTags: ' "$file" >/dev/null ; then
            sed -i -e "s%</body>%<!--RawTags: ${tags}-->\n</body>%" "$file"
        fi
    }
    
    process_post() {
    # Create backup directory if it doesn't exist
    local backup_dir="/tmp/shellcms-$(dirname ${file1})"
    mkdir -p "$backup_dir"
    
    # Backup the file
    cp -f "${file1}" "${backup_dir}/$(basename ${file1}).bak"
    
    # Process the content
    sed '1,/<body>/d;/<\/body>/Q' "${file1}" > .tmpfile
    
    if [[ $edit_mode == keep ]]; then
        parse_file_func ".tmpfile" "$edit_timestamp" "${file_sans_ext}.html"
    else
        parse_file_func ".tmpfile" "$edit_timestamp"
        mv -f "${file1}" "${filename%%.*}.htmraw" 2>/dev/null
    fi
    
    rm -f .tmpfile
    rm -f images
    }
    
    update_timestamps() {
        touch -t "$touch_timestamp" "$filename"
        touch -t "$touch_timestamp" "${filename/.html/.htmraw}"
        chmod 644 "$filename"
    }
    
    process_tags() {
        [ "${filename##*/}" == "index.html" ] && return 0
        
        local tags_before=$(tags_in_post_func "${filename/.html/.htmraw}")
        local tags_after=$(tags_in_post_func "$filename")
        local relevant_tags=$(echo "$tags_before $tags_after" | tr ',' ' ' | tr ' ' '\n' | sort -u | tr '\n' ' ')
        
        if [[ ! -z $relevant_tags ]]; then
            local relevant_posts="$(posts_with_tags_func $relevant_tags)"
            rebuild_tags "$relevant_posts" "$relevant_tags"
        fi
    }
    
    validate_file
    get_timestamps
    process_edit
    process_post
    update_timestamps
    process_tags
    
    echo "Posted $filename"
}

# Create a Twitter summary (twitter "card") for the post
#
# $1 the post file
# $2 the title
twitter_card() {
    [[ -z $global_twitter_username ]] && return
    
    echo "<meta name='twitter:card' content='summary' />"
    echo "<meta name='twitter:site' content='@$global_twitter_username' />"
    echo "<meta name='twitter:title' content='$2' />" # Twitter truncates at 70 char
    description=$(grep -v "^<p>$template_tags_line_header" "$1" | sed -e 's/<[^>]*>//g' | head -c 250 | tr '\n' ' ' | sed "s/\"/'/g") 
    echo "<meta name='twitter:description' content=\"$description\" />"
    image=$(sed -n 's/.*<img.*src="\([^"]*\)".*/\1/p' "$1" | head -n 1) # First image is fine
    [[ -z $image ]] && return
    [[ $image =~ ^https?:// ]] || image=$global_cms_url/$image # Check that URL is absolute
    echo "<meta name='twitter:image' content='$image' />"
}

# Adds the code needed by the twitter button
#
# $1 the post URL
twitter() {
    [[ -z $global_twitter_username ]] && return

    if [[ -z $global_disqus_username ]]; then
        if [[ $global_twitter_cookieless == true ]]; then 
            id=$RANDOM

            search_engine="https://twitter.com/search?q="

            echo "<p id='twitter'><a href='http://twitter.com/intent/tweet?url=$1&text=$template_twitter_comment&via=$global_twitter_username'>$template_comments $template_twitter_button</a> "
            echo "<a href='$search_engine""$1'><span id='count-$id'></span></a>&nbsp;</p>"
            return;
        else 
            echo "<p id='twitter'>$template_comments&nbsp;"; 
        fi
    else
        echo "<p id='twitter'><a href=\"$1#disqus_thread\">$template_comments</a> &nbsp;"
    fi  

    echo "<a href=\"https://twitter.com/share\" class=\"twitter-share-button\" data-text=\"$template_twitter_comment\" data-url=\"$1\""
    echo " data-via=\"$global_twitter_username\""
    echo ">$template_twitter_button</a>	<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=\"//platform.twitter.com/widgets.js\";fjs.parentNode.insertBefore(js,fjs);}}(document,\"script\",\"twitter-wjs\");</script>"
    echo "</p>"
}

# Adds all the bells and whistles to format the html page
# Every blog post is marked with a <!-- entry begin --> and <!-- entry end -->
# which is parsed afterwards in the other functions. There is also a marker
# 20230424 added customization to the classes for the header div and content, suited for bulmacss please be aware if you switch css file.
# <!-- text begin --> to determine just the beginning of the text body of the post
#
# $1     a file with the body of the content
# $2     the output file
# $3     "yes" if we want to generate the index.html,
#        "no" to insert new blog posts
# $4     title for the html header
# $5     original blog timestamp
# $6     post author
# Core page generation function
create_html_page() {
    local content="$1"
    local filename="$2"
    local page_type="$3"
    local title="$4"
    local timestamp="$5"
    local author="$6"
    
    local file_url=${filename#./}
    file_url=${file_url%.rebuilt}
    local nameonly="$(basename $filename .html)"

    {
        generate_page_header "$title" "$content"
        generate_page_body "$content" "$page_type" "$title" "$timestamp" "$author" "$file_url" "$nameonly"
        generate_page_footer "$page_type" "$nameonly"
        
    } > "$filename"

    post_process_page "$filename" "$page_type"
}

# Body generation with all conditionals
generate_page_body() {
    local content="$1"
    local page_type="$2"
    local title="$3"
    local timestamp="$4"
    local author="$5"
    local file_url="$6"
    local nameonly="$7"

    [[ -n $body_begin_file ]] && cat "$body_begin_file"
    
    echo '<div id="divbodyholder" class="column is-half-widescreen">'
    echo '<div class="headerholder"><div class="header">'
    echo '<div id="title">'
    cat .title.html
    echo '</div></div></div>'
    echo '<div id="divbody" class="colunms is-centered"><div class="column is-full"><div class="content">'

    if [[ $page_type == post ]]; then
        generate_post_entry "$title" "$timestamp" "$author" "$content" "$file_url" "$nameonly"
    else
        cat "$content"
    fi

    if [ "$page_type" == "tags" ]; then
        generate_tag_pagination "$nameonly" "$num_splits" "$cnt_splits"
    fi
}

# Post entry specific generation
generate_post_entry() {
    local title="$1"
    local timestamp="$2" 
    local author="$3"
    local content="$4"
    local file_url="$5"
    local nameonly="$6"

    echo '<!-- entry begin -->'
    generate_post_header "$title" "$file_url"
    generate_post_metadata "$timestamp" "$author"
    echo '<!-- text begin -->'
    
    cat "$content"
    
    if [ "$nameonly" == "index" ]; then
        echo "<hr />"
        onetag="$(grep -o '\-\-RawTags: .*\-\-' ${content} | tail -n 1 | tr -s ' ' | cut -f 2 -d ' ' | cut -f 1 -d '-')"
        category_index_func $onetag
        echo '<br />'
    fi

    echo -e '\n<!-- text end -->'
    twitter "$global_cms_url/$file_url"
    echo '<!-- entry end -->'
}

# Tag pagination handling
generate_tag_pagination() {
    local nameonly="$1"
    local num_splits="$2"
    local cnt_splits="$3"
    
    first_nameonly="${nameonly/-*/}"
    
    if [ $num_splits -gt 1 ]; then
        local next_split=$(($cnt_splits+1))
        local prev_split=$(($cnt_splits-1))
        
        generate_pagination_links "$first_nameonly" "$cnt_splits" "$prev_split" "$next_split" "$num_splits"
    fi
}

post_process_page() {
    local filename="$1"
    local page_type="$2"
    local subfolder="${filename%/*}"  # Extract subfolder path if present
    
    # Process paths based on both page type and location
    if [ "$page_type" != "post" ] && [ "$subfolder" == "$filename" ]; then
        # Top level non-post files - remove "../" prefix
        sed -i -e "s%href='\.\./tag_%href='tag_%g" $filename
        sed -i -e 's%src="\.\./images0/%src="images0/%g' $filename
        sed -i -e 's%href="\.\./css0/%href="css0/%g' $filename
        sed -i -e 's%src="\.\./css0/%src="css0/%g' $filename
    else
        # Posts and files in subfolders - add "../" prefix
        sed -i -e 's%src="images0/%src="../images0/%g' $filename
        sed -i -e 's%href="css0/%href="../css0/%g' $filename
        sed -i -e 's%src="css0/%src="../css0/%g' $filename
    fi

    # Handle category-specific banner
    if [ -f images/top-banner.png ]; then
        sed -i -e 's%\.\./images0/top-banner%images/top-banner%' $filename
    fi

    # Handle site home button and search box
    process_home_button "$filename" "button is-info is-light"
    process_search_box "$filename" "$page_type"
}
process_home_button() {
    local filename="$1"
    local css_button_style="$2"
    local page_type="$3"
    local subfolder="${filename%/*}"
    local image_prefix=""
    
    # Add "../" prefix for files in subfolders
    [ "$subfolder" != "$filename" ] && image_prefix="../"
    
    if [ "$global_site_url" != "$global_cms_url" ]; then
        case $MODE in
            document)
                if [[ $page_type != all_docs ]]; then
                    local ibPTN="s%.*THIRDBUTTON.*%\&nbsp;<a class=\"${css_button_style}\" href=\"${button_subhome_url}\"><img src=\"${image_prefix}images0/${button_subhome_icon}\" width=\"24\" height=\"24\" alt=\"subhome\" title=\"${button_subhome_tooltip}\" />${button_subhome_text}</a>%"
                    sed -i -e "$ibPTN" $filename
                fi
                ;;
            *)
                if [[ $page_type != index ]]; then
                    local ibPTN="s%.*THIRDBUTTON.*%\&nbsp;<a class=\"${css_button_style}\" href=\"${button_subhome_url}\"><img src=\"${image_prefix}images0/${button_subhome_icon}\" width=\"24\" height=\"24\" alt=\"subhome\" title=\"${button_subhome_tooltip}\" />${button_subhome_text}</a>%"
                    sed -i -e "$ibPTN" $filename
                fi
                ;;
        esac
    fi
}

# Footer with all conditionals
generate_page_footer() {
    local page_type="$1"
    local nameonly="$2"
    
    echo '</div></div>'
    
    [[ $page_type == post ]] && {
        disqus_body
        echo "<div class=\"content\">"
        echo "<div id=\"all_posts\"><a href=\"../${index_file}\">${template_archive_index_page}</a></div>"
        echo "</div>"
    }
    cat .footer.html
    echo '</div></div>'
    disqus_footer
    [[ -n $body_end_file ]] && cat "$body_end_file"
    echo '</body></html>'
}
generate_pagination_link() {
    local url="$1"
    local direction="$2"
    local message="$3"
    
    local arrow="&rarr;"
    [[ $direction == "prev" ]] && arrow="&larr;"
    
    echo "<div id=\"all_posts\"><a href=\"${url}\">${arrow} ${message}</a></div>"
}

get_prev_page_url() {
    local first_nameonly="$1"
    local prev_split="$2"
    
    if [ $prev_split -eq 1 ]; then
        echo "${first_nameonly}.html"
    else
        echo "${first_nameonly}-${prev_split}.html"
    fi
}

generate_pagination_links() {
    local first_nameonly="$1"
    local cnt_splits="$2"
    local prev_split="$3"
    local next_split="$4"
    local num_splits="$5"

    echo ' &nbsp; '

    case $cnt_splits in
        1)
            generate_pagination_link "${first_nameonly}-${next_split}.html" "next" "${older_page_link_msg}"
            ;;
        9)
            generate_pagination_link "$(get_prev_page_url "$first_nameonly" "$prev_split")" "prev" "${newer_page_link_msg}"
            generate_pagination_link "${archive_index}" "next" "${older_page_link_msg}"
            ;;
        *)
            if [ $cnt_splits -ge $num_splits ]; then
                generate_pagination_link "$(get_prev_page_url "$first_nameonly" "$prev_split")" "prev" "${newer_page_link_msg}"
            else
                generate_pagination_link "$(get_prev_page_url "$first_nameonly" "$prev_split")" "prev" "${newer_page_link_msg}"
                echo ' '
                generate_pagination_link "${first_nameonly}-${next_split}.html" "next" "${older_page_link_msg}"
            fi
            ;;
    esac
}

generate_page_header() {
    local title="$1"
    local content="$2"
    
    cat ".header.html"
    echo "<title>$title</title>"
    google_analytics
    twitter_card "$content" "$title"
    echo "</head><body>"
}

generate_post_header() {
    local title="$1"
    local file_url="$2"
    
    echo "<h3><a class=\"bblack\">"
    echo "<!--TITLEWITHLINK<h3><a class=\"ablack\" href=\"$file_url\">TITLEWITHLINK-->"
    title=${title//<p>/}
    title=${title//<\/p>/}
    echo "$title"
    echo '</a></h3>'
}

generate_post_metadata() {
    local timestamp="$1"
    local author="$2"
    
    local formatted_timestamp
    if [[ -z $timestamp ]]; then
        formatted_timestamp=$(LC_ALL=$date_locale date +"$date_format_timestamp")
        echo "<!-- $date_inpost: #${formatted_timestamp}# -->"
        echo -n "<div class=\"subtitle\">$(LC_ALL=$date_locale date +"$date_format")"
    else
        formatted_timestamp=$(LC_ALL=$date_locale date +"$date_format_timestamp" --date="$timestamp")
        echo "<!-- $date_inpost: #${formatted_timestamp}# -->"
        echo -n "<div class=\"subtitle\">$(LC_ALL=$date_locale date +"$date_format" --date="$timestamp")"
    fi
    
    [[ -n $author ]] && echo -e " &mdash; \n$author"
    echo "</div>"
}

process_search_box() {
    local filename="$1"
    local page_type="$2"
    
    if [ "$search_box_pages" ]; then
        local final_file_basename="$page_type"
        [ "$MODE" == "document" ] && [ "$final_file_basename" == "all_docs" ] && final_file_basename="index"
        
        if [ "$(echo " ${search_box_pages} " | grep " ${final_file_basename} ")" != "" ]; then
            form_xml="$(search_box_func | tr '\n' ' ')"
            ibPTN="s%.*SEVENTHBUTTON.*%${form_xml}%"
            sed -i -e "$ibPTN" $filename
        fi
    fi
}
#*before* creating or editing a post, ask for tag
# $1=file to edit. if existing file: $2=sub-folder
# $3 optional, preset tag.
ask_tags_func() {
    local post_file="$1"
    local subfolder="$2"
    local preset_tag="$3"

    # helper to grab current tags from the file
    get_current_tags() {
        grep -o '\-\-RawTags: .*' "${post_file}" \
          | tail -n1 \
          | sed -e 's/^--RawTags: //' -e 's/-->$//' \
          | tr ',' ' ' \
          | tr -s ' '
    }
    # helper to write them back
    update_tags() {
        local new_tags="$1"
        sed -i \
            -e "s%--RawTags: .*-->%--RawTags: ${new_tags}-->%" \
            "${post_file}"
    }

    # 1) start with whatever was already in the file
    local tags
    tags="$(get_current_tags)"

    # 2) override if a preset was passed in
    if [[ -n "$preset_tag" ]]; then
        tags="$preset_tag"

    # 3) only prompt if not in document‚Äêmode *or* subfolder is empty
    elif [[ "$MODE" != "document" || -z "$subfolder" ]]; then

        if (( INTERACTIVE )); then
        # build the tag key list as before‚Ä¶
        mapfile -t TAG_KEYS   < <(echo "$tag2header" | cut -f1 -d' ')
        mapfile -t TAG_LABELS < <(echo "$tag2header" | cut -f2- -d' ')

            if (( USE_GUM )); then
                # 1) select zero or more existing tags
                if [[ "$MODE" == "document" ]]; then
                    picked=$(gum choose "${TAG_KEYS[@]}")
                else
                    picked=$(gum choose --no-limit "${TAG_KEYS[@]}")
                fi

                # 2) optionally type in brand‚Äênew tags (comma‚Äëseparated)
                extra=$(gum input \
                    --placeholder "Add new tags (comma‚Äëseparated), or leave blank" \
                    --value "")

            else
                # 1) dialog checklist/radiolist as before
                local dlg_type
                if [[ "$MODE" == "document" ]]; then
                    dlg_type=(--radiolist "Select ONE tag:" 0 0 0)
                else
                    dlg_type=(--checklist "Select one or more tags:" 0 0 0)
                fi

                local dlg_args=()
                for i in "${!TAG_KEYS[@]}"; do
                    key=${TAG_KEYS[i]}; label=${TAG_LABELS[i]}
                    state=off
                    [[ " $tags " == *" $key "* ]] && state=on
                    dlg_args+=( "$key" "$label" "$state" )
                done

                picked=$(dialog --stdout "${dlg_type[@]}" "${dlg_args[@]}")
                extra=$(dialog --stdout \
                    --inputbox "Add new tags (comma‚Äëseparated), or leave blank:" \
                    0 0 "")
            fi

        # 3) merge picked + extra, normalize, dedupe
        #    turn space lists into comma lists, split commas into spaces
        # after picking & extra:
        combined=$(printf '%s\n%s' "$picked" "$extra" | tr '\n' ' '| tr ',' ' '| tr -s ' ')

        # build array & dedupe exactly as before
        read -r -a arr <<<"$combined"
        # use associative array for uniqueness
        declare -A seen=()
        tags_list=()
        for t in "${arr[@]}"; do
            [[ -n "$t" && -z "${seen[$t]}" ]] && {
                seen[$t]=1
                tags_list+=( "$t" )
            }
        done
        # if document‚Äêmode, only keep the first
        if [[ "$MODE" == "document" && "${#tags_list[@]}" -gt 1 ]]; then
            tags_list=( "${tags_list[0]}" )
        fi
        # final CSV
        tags=$(IFS=, ; echo "${tags_list[*]}")


        else
            # fallback to your original echo/read
            echo -n "Available tags: "
            echo "$tag2header" | cut -f1 -d' ' | tr '\n' ' '
            echo -e "\nYour current selection: ${tags}"
            [[ "$MODE" == "document" ]] && \
              echo 'NOTE: In "document" mode only ONE tag allowed per post.'
            read -p "Press ENTER to accept, or type replacement: " newtags
            if [[ -n "$newtags" ]]; then
                tags="$(echo -n "$newtags" | tr ',' ' ' | tr -s ' ')"
                [[ "$MODE" == "document" ]] && tags="${tags%% *}"
            fi
        fi
    fi


    # 4) if still empty, pick the very first tag in your list
    if [[ -z "$tags" ]]; then
        tags="$(echo "$tag2header" | cut -f1 -d' ' | head -n1)"
    fi

    # 5) write back and recreate the symlink
    update_tags "$tags"

    SUB1="${subfolder:-$([ "$MODE" == "document" ] \
               && echo "${tags%%,*}" \
               || date +%Y%m)}"
    mkdir -p "${SUB1}/images"
    ln -snf "${SUB1}/images" images
    echo "A temporary symlink created: images -> ${SUB1}/images"
}

#parse new or edited post.
# $1    source file name
# $2    (optional) timestamp for the file
# $3    (optional) destination file name
# note that although timestamp is optional, something must be provided at its
# place if destination file name is provided, i.e:
# parse_file_func source.txt "" destination.html
parse_file_func() {
 #read title
 #181004 sometimes <h1> is not at beginning of source...
 for Tline in 1 2 3 4 5
 do
  title="$(head -n ${Tline} ${1} | tail -n 1 | sed -e 's%<h1>%%' -e 's%<.*%%g' | sed -e 's%^ *%%' -e 's% *$%%')"
  [ "$title" ] && break
 done
 [ ! "$title" ] && title="dummy title coz not found in first line"
 if [[ -n $3 ]]; then
  filename=$3
 else
  filename=$title
  [[ -n $convert_filename ]] && filename="$(echo "$title" | eval "$convert_filename")"
  [[ -n $filename ]] || filename="$RANDOM" # don't allow empty filenames
  filename=$filename.html
 fi
 content=${filename}.tmp
 
 #SM is annoying, inserts "<br>" all over the place, including in the <h1>title here<br>\n</h1>
 #echo "<h1>${title}</h1>" > $content NO, coz create_html_page inserts title.
 #sed '1,/<\/h1>/d' ${1} > $content #copy everything past "</h1>"
 #...hmmm, removes everything, apparently coz pattern is on first line. this works:
 sed '0,/<\/h1>/d' ${1} > $content #copy everything past "</h1>"
 #for the record, echo -e ' <h1>title<br>\n</h1>\nnext line\nanother line' | sed '1,/<\/h1>/d'
 #works, but not if </h1> is on line-1. the '0,/...' works both cases.
 
 #read tags, append hyperlinks to post...
 css_style_tag="tag is-info is-light"
 tags="$(grep -o '\-\-RawTags: .*' ${1} | tail -n 1 | tr ',' ' ' | tr -s ' ' | sed -e 's%^--RawTags: %%' -e 's%-->$%%')"
 [ ! "$tags" ] && err_exit "<!--RawTags: ...> missing from ${i}"
 if [ "${filename##*/}" != "index.html" ];then #index.html page has tag-posts index inserted (see create_html_page)
  #note: new <category>/index.html post, filename=index.html content=index.html.tmp. 
  # when edit it, filename=<category>/index.html content=<category>/index.html.tmp.
  echo -n "<p>${template_tags_line_header} " >> $content #"Tags:"
  for atag in $tags
  do
   #posts are in sub-folders, so insert "../" here.
   echo -n "<a class=\"${css_style_tag}\"href='../tag_${atag}.html'>${atag}</a>, "
  done | sed 's%, $%</p>%' >> "$content"
 fi
 
 # Create the actual html page
 [ -f $filename ] && mv -f $filename /tmp/shellcms-${filename}.bak #precaution.
 #ex: content='easyapps/index.html.tmp' filename='easyapps/index.html' title='Introducing EasyShare' 2='Tue, 16 Jan 2018 17:05:48 +0800' global_author='BarryK'
 create_html_page "$content" "$filename" post "$title" "$2" "$global_author"
 rm -f "$content"
}

#Creation of new post, or edit a draft.
#new post:              $1=<path> $2=post ex: www post
#                       creates a new post, with filename derived from post title
#new post, forced name: ex: www post admin/index.htmraw
#                       creates a new post, in a sub-folder and with a 
#                       predetermined filename. document mode only.
#edit draft:            $1=<path> $2=post $3=drafts/<filename> 
#                       ex: www post drafts/this-is-a-draft-post.htmraw
write_entry_func() {
 fmt=htmraw; file2edit=''
 SUBFOLDER=""; pretag=''; prename=''
 [ $3 ] && file2edit="$3"
 if [ "$file2edit" ];then
  filenameonly="${file2edit/.*/}" #drop the extension.
  basenameonly="$(basename $filenameonly)"
  dirnameonly="${filenameonly%%/*}"
  [ "$dirnameonly" == "." ] && err_exit "'${file2edit}' must be in a folder"
  [ ! -d ${dirnameonly} ] && err_exit "folder '${dirnameonly}' must exist"
  [ -d ${dirnameonly}/cms_config ] && err_exit "folder '${dirnameonly}' is in a nested shellCMS"
  
  mv -f index.html ..index.html #temp relocate, in case creating <sub-folder>/index.html
  
  if [ "${dirnameonly}" == "drafts" ];then #ex: filenameonly=drafts/a-draft-post
   [ ! -f drafts/${basenameonly}.htmraw ] && err_exit "'drafts/${basenameonly}.htmraw' does not exist"
   mv -f drafts/${basenameonly}.html ./ 2>/dev/null
   mv -f drafts/${basenameonly}.htmraw ./
   TMPFILE="${basenameonly}.htmraw"
  else
   [ "$MODE" != "document" ] && err_exit "shellCMS MODE must be 'document'"
   cat cms_config/cms_skeleton.txt > ${basenameonly}.htmraw
   SUBFOLDER="$dirnameonly"
   pretag="$dirnameonly"
   prename="${basenameonly}"
   TMPFILE="${basenameonly}.htmraw"
  fi
 else
  rm .entry-*.htmraw 2>/dev/null #precaution
  rm .entry-*.html 2>/dev/null   #precaution
  TMPFILE=.entry-$RANDOM.$fmt
  cat cms_config/cms_skeleton.txt > $TMPFILE
 fi
 
 chmod 600 "$TMPFILE"
 post_status="E"
 filename=""
 while [[ $post_status != "p" && $post_status != "P" ]]; do
  [[ -n $filename ]] && rm -f "$filename" # Delete the generated html file, if any
        
  ask_tags_func $TMPFILE "$SUBFOLDER" "$pretag" #creates temp 'images' symlink, sets $tags
  ${EDITOREXE} ${PWD}/${TMPFILE} 2>/dev/null #mozeditor requires full path, also spits out on stderr.
  
  #crap, SM Composer is set for "prettyprint" but sometimes totally screws up,
  #generates almost everything on one line. make sure these are on new lines:
  sed -i -e 's%<body>.*<h1>%\n<body>\n<h1>%' ${TMPFILE}
  sed -i -e 's%<!--RawTags%\n<!--RawTags%' -e 's%</body>%\n</body>%' -e 's%</html>%\n</html>%' ${TMPFILE}

  #it is unlikely, but possible, that "<!--RawTags: ..." line got deleted in editor
  if ! grep '\-\-RawTags: ' ${TMPFILE} >/dev/null ; then
   sed -i -e "s%</body>%<!--RawTags: ${tags}-->\n</body>%" ${TMPFILE}
  fi
 
  #precaution, save the post somewhere:
  cp -f ${TMPFILE} /tmp/shellcms-post-bak
        
  sed '1,/<body>/d;/<\/body>/Q' ${TMPFILE} > .tmpfile #leave only inside body tags.
  if [ "$prename" ];then
   parse_file_func ".tmpfile" "" "${prename}.html" #creates $filename
  else
   parse_file_func ".tmpfile" "" #creates $filename
  fi
  rm -f .tmpfile
  rm -f images #remove temporary symlink.
  nameonly="${filename%%.*}"
  
  chmod 644 "$filename"
  
if (( INTERACTIVE )); then
    if (( USE_GUM )); then
        # gum multi‚Äëchoice (but limit to 1)
        post_status=$(gum choose --limit=1 \
        "üì§ p  - Post (publish)" \
        "‚úèÔ∏è  e  - Edit again" \
        "üóÇ  d  - Draft (save for later)")

        # Extract 'p', 'e', or 'd' from the selected line
        post_status=$(echo "$post_status" | awk '{print $2}')
    else
        # dialog radiolist
        post_status=$(dialog --stdout --radiolist "Choose action:" 0 0 0 \
        p "Post this entry" on \
        e "Edit again"      off \
        d "Draft for later" off)
    fi
  # if user hit ESC or closed dialog, exit
  [[ $? -ne 0 || -z $post_status ]] && exit
else
  # non‚Äëinteractive CLI fallback
  read -r -p "[P]ost, [E]dit again, [D]raft? (p/E/d) " post_status
fi

  if [[ $post_status == d || $post_status == D ]]; then
   mkdir -p "drafts/"
   chmod 700 "drafts/"
   
   title="$nameonly" #171110 $(head -n 1 $TMPFILE)
   [[ -n $convert_filename ]] && title=$(echo "$title" | eval "$convert_filename")
   [[ -n $title ]] || title=$RANDOM

   draft=drafts/$title.$fmt
   mv -f "$TMPFILE" "$draft"
   chmod 600 "$draft"
   rm "$filename"
   delete_includes
   echo "Saved your draft as '$draft'"
   exit
  fi
 done
    
 [ "$TMPFILE" != "${nameonly}.htmraw" ] && mv -f "$TMPFILE" "${nameonly}.htmraw"
 chmod 644 "$filename"
 relevant_tags=$(tags_in_post_func $filename)
    
 #move post into a sub-folder
 case $MODE in
  document)
   mkdir -p $relevant_tags #only one tag allowed.
   #[ ! -e $relevant_tags/images ] && ln -s ../images $relevant_tags/images
   if [ ! -f $relevant_tags/index.html ];then
    #redirect to ../tag_$relevant_tags.html
    echo -e "<html>\n<head>\n<meta http-equiv=\"refresh\" content=\"0; url=${global_cms_url}/tag_${relevant_tags}.html\" />\n<title></title>\n</head>\n<body>\n</body>\n</html>
    " > $relevant_tags/index.html
   fi
   echo "Posted ${relevant_tags}/${nameonly}.html"
   mv -f ${nameonly}.htmraw ${relevant_tags}/${nameonly}.htmraw
   mv -f ${nameonly}.html ${relevant_tags}/${nameonly}.html
   sub_folder="$relevant_tags"
  ;;
  *)
   sub_folder="$(grep -o 'bashblog_timestamp: #[0-9][0-9][0-9][0-9][0-9][0-9]' ${nameonly}.html | cut -f 2 -d '#')" #ex: 201708
   mkdir -p $sub_folder
   #[ ! -e $sub_folder/images ] && ln -s ../images $sub_folder/images
   if [ ! -f $sub_folder/index.html ];then
    echo '<html><header></header><body>nothing here</body></html>' > $sub_folder/index.html
   fi
   echo "Posted ${sub_folder}/${nameonly}.html"
   mv -f ${nameonly}.htmraw ${sub_folder}/
   mv -f ${nameonly}.html ${sub_folder}/
  ;;
 esac
 [ -f ..index.html ] && mv -f ..index.html index.html #temp relocated.
    
 #this line got created earlier, ex:
 #<!--TITLEWITHLINK<h3><a class="ablack" href="shellcms-uploaded-online-docs.html">TITLEWITHLINK-->
 #it gets uncommented when the post is inserted into a top-level index file,
 #so need to fix the href
 if [ "$(grep "TITLEWITHLINK.*${sub_folder}/" ${sub_folder}/${nameonly}.html)" == "" ];then #precaution, not needed though.
  PTN="s%<h3><a class=\"ablack\" href=\"%<h3><a class=\"ablack\" href=\"${sub_folder}/%"
  sed -i -e "$PTN" ${sub_folder}/${nameonly}.html
 fi
 
 [ "${nameonly}" == "index" ] && return 0 #category-index pages are a special case, do not rebuild tag_*.html.

 if [[ -n $relevant_tags ]]; then
  echo "Finding all posts with these tags: ${relevant_tags}" #TEST
  #hack for hiccup when creating post...
  existing_relevant_posts="$(posts_with_tags_func $relevant_tags)"
  if [ "$(echo "${existing_relevant_posts}" | grep "${sub_folder}/${filename}")" == "" ];then
   relevant_posts="$(posts_with_tags_func $relevant_tags) ${sub_folder}/$filename"
  else
   relevant_posts="$existing_relevant_posts"
  fi
  echo "relevant_posts=${relevant_posts}" #TEST
  echo "Rebuilding all relevant tag_*.html files" #TEST
  rebuild_tags "$relevant_posts" "$relevant_tags"
 fi
}

# Create an index page with all the posts. creates all_posts.html
all_posts() {
    echo -n "Creating an index page with all the posts "
    contentfile=$archive_index.$RANDOM
    while [[ -f $contentfile ]]; do
        contentfile=$archive_index.$RANDOM
    done

    {
        echo "<h3>$template_archive_title</h3>"
        prev_month=""
        while IFS='' read -r i0; do
            i=${i0/.htmraw/.html}
            [ -d ${i%/*}/cms_config ] && continue #ex: ./news/cms_config is a nested shellCMS
            [ "${i##*/}" == "index.html" ] && continue #i=./admin/index.html, extract index.html
            echo -n "." 1>&3
            # Month headers
            month=$(LC_ALL=$date_locale date -r "$i" +"$date_allposts_header")
            if [[ $month != "$prev_month" ]]; then
                [[ -n $prev_month ]] && echo "</ul>"  # Don't close ul before first header
                echo "<h4 class='allposts_header'>$month</h4>"
                echo "<ul>"
                prev_month=$month
            fi
            # Title
            title=$(get_post_title "$i")
            echo -n "<li><a href=\"$i\">$title</a> &mdash;"
            # Date
            date=$(LC_ALL=$date_locale date -r "$i" +"$date_format")
            echo " $date</li>"
        done < <(ls -t ./*/*.htmraw)
        echo "" 1>&3
        echo "</ul>"
        echo "<div id=\"all_posts\"><a href=\"./$index_file\">$template_archive_index_page</a></div>"
    } 3>&1 >"$contentfile"
    
    create_html_page "$contentfile" "$archive_index.tmp" all_posts "$global_title &mdash; $template_archive_title" "$global_author" #170830b
    mv "$archive_index.tmp" "$archive_index"
    chmod 644 "$archive_index"
    rm "$contentfile"
}

#create a index of posts, for a particular category. intention is to insert this into a index.html category-frontpage
category_index_func() {
 local i0
 local i
 i0="$1" #passed param is tag.
 [ ! -f tag_${i0}.html ] && exit 1
 for i in `ls -1 tag_${i0}.html tag_${i0}-*.html 2>/dev/null | sort -V`
 do
  nposts=$(grep -c "<\!-- text begin -->" "$i")
  tagname=${i#tag_}
  tagname=${tagname%.html}
             
  #may have split pages, ex: admin, admin-2, admin-3. heading only for first:
  if [ "${tagname/*-[0-9]/}" ];then #only true when no "-n"
  # #replace tagname with more meaningful header
  # tagheader="$(echo "$tag2header" | grep "^${tagname} " | cut -f 2- -d ' ')"
  # [ ! "$tagheader" ] && tagheader="$tagname"
  # echo "<h3>${tagheader}</h3>"
   echo "<h3>${category_frontpage_linkstitle}</h3>"
  fi
  
             
  #read title and link of each post from the tag_*.html file. file ex: tag_bashblog.html
  while read linkfile
  do
   read linktitle
   read aseparator
   linkbase="${linkfile##*/}" #ex: linkfile=admin/a-post.html, extract a-post.html
   [ "$linkbase" != "index.html" ] && echo "<a href=\"${linkbase}\">${linktitle}</a><br />"
  done<<EOF
$(grep -A 1 -e 'class="ablack"' ${i} | cut -f 4 -d '"')
EOF
 done
}

#create an index page with all posts, organized by category (tag). creates all_docs.html
all_docs_func() {
    echo -n "Creating an index page with all the docs "
    contentfile=$docs_index.$RANDOM
    while [[ -f $contentfile ]]; do
        contentfile=$docs_index.$RANDOM
    done

    {
        echo "<h3>$template_docs_title</h3>"
        echo "<ul>"
        for i in `ls -1 tag_*.html | sort -V`; do
            [[ -f "$i" ]] || break
            echo -n "." 1>&3
            nposts=$(grep -c "<\!-- text begin -->" "$i")
            tagname=${i#"tag_"}
            tagname=${tagname%.html}
            
            #may have split pages, ex: admin, admin-2, admin-3. heading only for first:
            if [ "${tagname/*-[0-9]/}" ];then
             #replace tagname with more meaningful header
             tagheader="$(echo "$tag2header" | grep "^${tagname} " | cut -f 2- -d ' ')"
             [ ! "$tagheader" ] && tagheader="$tagname"
             #make this into a link to category frontpage... and image...
             if [ -f ${tagname}/images/logo48.png ];then
              echo "<h3 style=\"margin-bottom:5px\"><a href=\"${tagname}/index.html\"><img src=\"${tagname}/images/logo48.png\" align=\"top\" width=\"48\" height=\"48\" /><span style=\"position:absolute;padding-left:5px;padding-top:14px\">${tagheader}</span></a></h3>"
             else
              echo "<h3><a href=\"${tagname}/index.html\">${tagheader}</a></h3>"
             fi
            fi
            
            #read title and link of each post from the tag_*.html file. file ex: tag_bashblog.html
            while read linkfile
            do
             read linktitle
             read aseparator
             linkbase="${linkfile##*/}" #ex: linkfile=admin/a-post.html, extract a-post.html
             [ "$linkbase" != "index.html" ] && echo "<a href=\"${linkfile}\" style=\"padding-left:10px\">${linktitle}</a><br />"
            done<<EOF
$(grep -A 1 -e 'class="ablack"' ${i} | cut -f 4 -d '"')
EOF
            
        done
        echo "" 1>&3
        echo "</ul>"
        case $MODE in
         document) echo "<div id=\"all_posts\"><a href=\"$archive_index\">${docs_history}</a></div>" ;;
         *)        echo "<div id=\"all_posts\"><a href=\"./$index_file\">$template_archive_index_page</a></div>" ;;
        esac
    } 3>&1 > "$contentfile"

    create_html_page "$contentfile" "$docs_index.tmp" all_docs "$global_title &mdash; $template_tags_title" "$global_author" #170830b
    mv "$docs_index.tmp" "$docs_index"
    chmod 644 "$docs_index"
    rm "$contentfile"
    case $MODE in #170828 BK
     document)
      ibPTN="s%.*THIRDBUTTON.*%\&nbsp;<a href=\"./${archive_index}\"><img src=\"images0/${button_history_icon}\" width=\"24\" height=\"24\" title=\"${button_history_tooltip}\" />${button_history_text}</a>%"
      sed -i -e "$ibPTN" $docs_index
     ;;
    esac
}

# Create an index page with all the tags. creates all_tags.html
all_tags() {
    echo -n "Creating an index page with all the tags "
    contentfile=$tags_index.$RANDOM
    while [[ -f $contentfile ]]; do
        contentfile=$tags_index.$RANDOM
    done

    {
        echo "<h3>$template_tags_title</h3>"
        echo "<ul>"
        #for i in tag_*.html; do
        for i in `ls -1 tag_*.html | sort -V`; do
            [[ -f "$i" ]] || break
            echo -n "." 1>&3
            nposts=$(grep -c "<\!-- text begin -->" "$i")
            tagname=${i#"tag_"}
            tagname=${tagname%.html}
            case $nposts in
                1) word=$template_tags_posts_singular;;
                2|3|4) word=$template_tags_posts_2_4;;
                *) word=$template_tags_posts;;
            esac
            #replace tagname with more meaningful header
            tagheader="$(echo "$tag2header" | grep "^${tagname} " | cut -f 2- -d ' ' | head -n 1)"
            [ ! "$tagheader" ] && tagheader="$tagname"
            echo "<li><a href=\"$i\">$tagheader</a> &mdash; $nposts $word</li>"
        done
        echo "" 1>&3
        echo "</ul>"
        echo "<div id=\"all_posts\"><a href=\"./$index_file\">$template_archive_index_page</a></div>"
    } 3>&1 > "$contentfile"

    create_html_page "$contentfile" "$tags_index.tmp" all_tags "$global_title &mdash; $template_tags_title" "$global_author" #170830b
    mv "$tags_index.tmp" "$tags_index"
    chmod 644 "$tags_index"
    rm "$contentfile"
}

# Generate the index.html with the content of the latest posts. creates index.html (replaced by all_docs.html in document mode)

rebuild_index() {
    echo -n "Rebuilding the index "
    [ -e $index_file ] && rm -f $index_file
    
    # Get valid posts (excluding nested CMS and index files)
    local valid_posts=$(ls -t ./*/*.htmraw | while read -r post; do
        [ -d ${post%/*}/cms_config ] && continue
        [ "${post##*/}" == "index.htmraw" ] && continue
        echo "$post"
    done)
    
    local page_number=1
    local total_posts=$(echo "$valid_posts" | wc -l)
    local total_pages=$(( (total_posts + posts_per_page - 1) / posts_per_page ))
    
    echo "$valid_posts" | xargs -n$posts_per_page | while read -r chunk; do
        local page_file
        local temp_file="index.$RANDOM.tmp"
        
        if [ $page_number -eq 1 ]; then
            page_file="$index_file"
        else
            page_file="index-${page_number}.html"
        fi
        
        generate_index_page "$chunk" "$temp_file" "$page_number" "$total_pages"
        
        # Process buttons and links
        css_button_style="button is-info is-light"
        ibPTN="s%.*THIRDBUTTON.*%\&nbsp;<a class=\"${css_button_style}\" href=\"./${archive_index}\"><img src=\"images0/${button_history_icon}\" width=\"24\" height=\"24\" title=\"${button_history_tooltip}\" />${button_history_text}</a>%"
        sed -i -e "$ibPTN" "$temp_file"
        
        ibPTN="s%.*FOURTHBUTTON.*%\&nbsp;<a class=\"${css_button_style}\" href=\"./${tags_index}\"><img src=\"images0/${button_tagsindex_icon}\" width=\"24\" height=\"24\" title=\"${button_tagsindex_tooltip}\" />${button_tagsindex_text}</a>\&nbsp;%"
        sed -i -e "$ibPTN" "$temp_file"
        
        # Fix title links
        sed -i '/"bblack"/d' "$temp_file"
        sed -i -e 's%^<!--TITLEWITHLINK%%' -e 's%TITLEWITHLINK-->$%%' "$temp_file"
        
        mv "$temp_file" "$page_file"
        chmod 644 "$page_file"
        
        page_number=$((page_number + 1))
    done
    
    echo ""
}
generate_index_page() {
    local posts="$1"
    local output_file="$2"
    local current_page="$3"
    local total_pages="$4"
    
    local content_file="${output_file}.content"
    
    {
        for post in $posts; do
            post=${post/.htmraw/.html}
            [ -d ${post%/*}/cms_config ] && continue
            [ "${post##*/}" == "index.html" ] && continue
            
            if [[ -n $cut_do ]]; then
                part_content="$(get_html_file_content 'entry' 'entry' 'cut' <"$post" | 
                    awk "/$cut_line/ { print \"<p class=\\\"readmore\\\"><a href=\\\"$post\\\">$template_read_more</a></p>\" ; next } 1")"
            else
                part_content="$(get_html_file_content 'entry' 'entry' <"$post")"
            fi
            #170831d fix image links
            part_sub_folder="$(dirname $post)"
            part_content="$(fix_image_links "$part_content" "$part_sub_folder")"

            
            echo "$part_content"
            echo -n "." 1>&3
        done
        
        generate_pagination_nav "$current_page" "$total_pages"
        
    } 3>&1 > "$content_file"

    create_html_page "$content_file" "$output_file" index "$global_title" "$global_author"
    rm "$content_file"
}
# Function to fix image links for a post
fix_image_links() {
    local content="$1"
    local sub_folder="$2"
    
    if [ "$sub_folder" != "." ]; then
        echo "$content" | sed -e "s#src=\"images/#src=\"${sub_folder}/images/#g"
    else
        echo "$content"
    fi
}


generate_pagination_nav() {
    local current_page="$1"
    local total_pages="$2"
    
    local feed=$blog_feed
    [[ -n $global_feedburner ]] && feed=$global_feedburner
    
    echo "<div class=\"content\">"
    echo "<div class=\"content\">"
    
    if [ $current_page -gt 1 ]; then
        if [ $current_page -eq 2 ]; then
            echo "<span><a href=\"index.html\">&larr; ${newer_page_link_msg}</a></span>"
        else
            echo "<span><a href=\"index-$((current_page-1)).html\">&larr; ${newer_page_link_msg}</a></span>"
        fi
    fi
    
    if [ $current_page -lt $total_pages ]; then
        echo "<span><a href=\"index-$((current_page+1)).html\">${older_page_link_msg} &rarr;</a></span>"
    fi
    
    echo "</div>"
    
    echo "<div id=\"all_posts\"><a href=\"$archive_index\">$template_archive</a> &mdash; <a href=\"$tags_index\">$template_tags_title</a> &mdash; <a href=\"$feed\"><img src=\"images0/${button_rss_icon}\" width=\"24\" height=\"24\" title=\"${button_rss_tooltip}\" />${button_rss_text}</a></div>"
    echo "</div>"
}

# Finds all tags referenced in one post.
# Accepts either filename as first argument, or post content at stdin
# Prints one line with space-separated tags to stdout.
tags_in_post_func() {
    local post_file="$1"
    local tagsinpost="$(grep -o '\-\-RawTags: .*\-\-' "${post_file}" | tail -n 1 | tr ',' ' ' | tr -s ' ' | cut -f 2- -d ' ' | cut -f 1 -d '-')"
    echo "$tagsinpost"
}

# Finds all posts referenced in a number of tags.
# Arguments are tags
# Prints one line with space-separated tags to stdout
# Find all posts containing specified tags
posts_with_tags_func() {
    [ ! $1 ] && return
    
    for aTAG in $@
    do
        grep --files-with-matches "<!--RawTags:.* ${aTAG}" `ls -1 ./*/*.htmraw | tr '\n' ' '` > /tmp/bashblog-posts-tagmatches
    done
    
    local posts_fnd="$(sort -u /tmp/bashblog-posts-tagmatches | sed -e 's%^\./%%' -e 's%htmraw$%html%' | tr '\n' ' ')"
    echo "$posts_fnd"
}

# Rebuilds tag_*.html files
# if no arguments given, rebuilds all of them
# if arguments given, they should have this format:
# "FILE1 [FILE2 [...]]" "TAG1 [TAG2 [...]]"
# where FILEn are files with posts which should be used for rebuilding tags,
# and TAGn are names of tags which should be rebuilt.
# example:
# rebuild_tags "one_post.html another_article.html" "example-tag another-tag"
# mind the quotes!
# Rebuild tag pages
rebuild_tags() {
    local param1="$1"
    local files
    local tags="$2"
    local all_tags
    
    if (($# < 2)); then
        files=$(ls -1 -t ./*/*.htmraw | sed -e 's%\.htmraw$%.html%')
        all_tags=yes
    else
        files="$(ls -1 -t $param1)"
    fi
    
    echo -n "Rebuilding tag pages "
    
    if [[ -n $all_tags ]]; then
        rm ./"tag_"*.html &> /dev/null
    else
        for i in $tags; do
            rm "./tag_$i.html" &> /dev/null
            rm "./tag_${i}-*.html" &> /dev/null
        done
    fi
    
    process_tag_files "$files" "$tags" "$all_tags"
}
process_tag_files() {
    local files="$1"
    local tags="$2"
    local all_tags="$3"
    
    # Clear existing count files
    rm -f /tmp/shellcms-cnt-posts-in-* 2>/dev/null
    
    fix_post_links() {
        local tmpfile="$1"
        local post_file="$2"
        local part_sub_folder="$(dirname $post_file)"
        
        if [ "$part_sub_folder" != "." ]; then
            sed -i -e "s%src=\"images/%src=\"${part_sub_folder}/images/%" "$tmpfile"
        fi
        
        # Restore href in post title
        sed -i '/"bblack"/d' "$tmpfile"
        sed -i -e 's%^<!--TITLEWITHLINK%%' -e 's%TITLEWITHLINK-->$%%' "$tmpfile"
    }
    
    process_file_content() {
        local file="$1"
        local tmpfile="$2"
        
        if [[ -n $cut_do ]]; then
            if [ "$MODE" == "document" ]; then
                process_document_mode "$file" "$tmpfile"
            else
                process_blog_mode "$file" "$tmpfile"
            fi
        else
            get_html_file_content 'entry' 'entry' < "$file" > "$tmpfile"
        fi
    }
    
    process_document_mode() {
        local file="$1"
        local tmpfile="$2"
        
        sed -e '/<\!-- text begin -->/,/<\!-- text end -->/ {
            s%<[du]%\n<hr />&%g
            s%<table%\n<hr /><table%g
            s%<p%\n<p%g
            s%<br%\n<br%g
        }' \
        -e '/^ *$/d' \
        -e '80,/<\!-- text end -->/ {
            s%<p%\n<hr /><p%
            s%<br%\n<hr /><br%
        }' "$file" | \
        get_html_file_content 'entry' 'entry' 'cut' | \
        add_read_more_link "$file" > "$tmpfile"
    }
    
    process_blog_mode() {
        local file="$1"
        local tmpfile="$2"
        
        get_html_file_content 'entry' 'entry' 'cut' < "$file" | \
        add_read_more_link "$file" > "$tmpfile"
    }
    
    add_read_more_link() {
        local file="$1"
        awk "/$cut_line/ { print \"<p class=\\\"readmore\\\"><a href=\\\"$file\\\">$template_read_more</a></p>\" ; next } 1"
    }
    
    process_tags() {
        local tmpfile="$1"
        local file="$2"
        local tags_found="$3"
        
        for tag in ${tags_found}; do
            if [[ -n $all_tags || " $tags " == *" $tag "* ]]; then
                echo "" >> /tmp/shellcms-cnt-posts-in-${tag}
                local cnt_posts=$(cat /tmp/shellcms-cnt-posts-in-${tag} | wc -l)
                local split_num=$((cnt_posts / number_of_index_articles + 1))
                [ $split_num -gt 9 ] && continue 2
                cat "$tmpfile" >> "tag_${tag}-${split_num}".tmp.html
            fi
        done
    }
    
    # Main processing loop
    local tmpfile=tmp.$RANDOM
    while [[ -f $tmpfile ]]; do 
        tmpfile=tmp.$RANDOM
    done
    
    while IFS='' read -r i; do
        [ "${i##*/}" == "index.html" ] && continue
        echo -n "."
        
        process_file_content "$i" "$tmpfile"
        fix_post_links "$tmpfile" "$i"
        
        local tags_fnd="$(tags_in_post_func "$i")"
        process_tags "$tmpfile" "$i" "$tags_fnd"
        
    done <<< "$files"
    
    rm "$tmpfile"
    finalize_tag_pages
}

process_post_content() {
    local tmpfile="$1"
    local post_file="$2"
    local part_sub_folder="$(dirname $post_file)"
    
    if [ "$part_sub_folder" != "." ]; then
        sed -i -e "s%src=\"images/%src=\"${part_sub_folder}/images/%" "$tmpfile"
    fi
    
    # Restore href in post title
    sed -i '/"bblack"/d' "$tmpfile"
    sed -i -e 's%^<!--TITLEWITHLINK%%' -e 's%TITLEWITHLINK-->$%%' "$tmpfile"
}

finalize_tag_pages() {
    while IFS='' read -r i; do
        tagname=${i#./"tag_"}
        tagname=${tagname%.tmp.html}
        
        cnt_splits=${tagname/*-/}
        realtagname=${tagname/-*/}
        num_splits=$(ls -1 tag_${realtagname}-*.tmp.html | wc -l)
        [ $cnt_splits -eq 1 ] && tagname="$realtagname"
        
        create_html_page "$i" "tag_${tagname}.html" tags "$global_title &mdash; $template_tag_title \"$tagname\"" "$global_author"
    done < <(ls -t ./tag_*.tmp.html 2>/dev/null)
    
    rm -f ./tag_*.tmp.html
    echo
}

# Return the post title
#
# $1 the html file
get_post_title() {
    awk '/<h3><a class="ablack" href=".+">/, /<\/a><\/h3>/{if (!/<h3><a class="ablack" href=".+">/ && !/<\/a><\/h3>/) print}' "$1"
}

# Return the post author
#
# $1 the html file
get_post_author() { 
    awk '/<div class="subtitle">.+/, /<!-- text begin -->/{if (!/<div class="subtitle">.+/ && !/<!-- text begin -->/) print}' "$1" | sed 's/<\/div>//g'
}

# Displays a list of the tags
#
# $3 if "-n", tags will be sorted by number of posts
list_tags() {
    if [[ $3 == -n ]]; then do_sort=1; else do_sort=0; fi

    ls ./tag_*.html &> /dev/null
    (($? != 0)) && echo "No posts yet. Use 'shellcms ${path_cms_top} post' to create one" && return

    lines=""
    for i in tag_*.html; do
        [[ -f "$i" ]] || break
        nposts=$(grep -c "<\!-- text begin -->" "$i")
        tagname=${i#"tag_"}
        tagname=${tagname#.html}
        ((nposts > 1)) && word=$template_tags_posts || word=$template_tags_posts_singular
        line="$tagname # $nposts # $word"
        lines+=$line\\n
    done

    if (( do_sort == 1 )); then
        echo -e "$lines" | column -t -s "#" | sort -nrk 2
    else
        echo -e "$lines" | column -t -s "#" 
    fi
}

# Displays a list of the posts
list_posts() {
    ls ./*/*.htmraw &> /dev/null
    (($? != 0)) && echo "No posts yet. Use 'shellcms ${path_cms_top} post' to create one" && return

    lines=""
    n=1
    while IFS='' read -r i0; do
        i=${i0/.htmraw/.html}
        [ -d ${i%/*}/cms_config ] && continue #ex: ./news/cms_config is a nested shellCMS
        line="$n # $(get_post_title "$i") # $(LC_ALL=$date_locale date -r "$i" +"$date_format")"
        lines+=$line\\n
        n=$(( n + 1 ))
    done < <(ls -t ./*/*.htmraw)

    echo -e "$lines" | column -t -s "#"
}

# Generate the feed file
make_rss() {
    echo -n "Making RSS "

    rssfile=$blog_feed.$RANDOM
    while [[ -f $rssfile ]]; do rssfile=$blog_feed.$RANDOM; done

    {
        pubdate=$(LC_ALL=C date +"$date_format_full")
        echo '<?xml version="1.0" encoding="UTF-8" ?>' 
        echo '<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/">' 
        echo "<channel><title>$global_title</title><link>$global_cms_url/$index_file</link>"
        echo "<description>$global_description</description><language>en</language>"
        echo "<lastBuildDate>$pubdate</lastBuildDate>"
        echo "<pubDate>$pubdate</pubDate>"
        echo "<atom:link href=\"$global_cms_url/$blog_feed\" rel=\"self\" type=\"application/rss+xml\" />"
    
        n=0
        while IFS='' read -r i0; do
            i=${i0/.htmraw/.html}
            [ -d ${i%/*}/cms_config ] && continue #ex: ./news/cms_config is a nested shellCMS
            ((n >= number_of_feed_articles)) && break # max 10 items
            echo -n "." 1>&3
            echo '<item><title>' 
            get_post_title "$i"
            echo '</title><description><![CDATA[' 
            get_html_file_content 'text' 'entry' $cut_do <"$i"
            echo "]]></description><link>$global_cms_url/${i#./}</link>" 
            echo "<guid>$global_cms_url/$i</guid>" 
            echo "<dc:creator>$(get_post_author "$i")</dc:creator>" 
            echo "<pubDate>$(LC_ALL=C date -r "$i" +"$date_format_full")</pubDate></item>"
    
            n=$(( n + 1 ))
        done < <(ls -t ./*/*.htmraw)
    
        echo '</channel></rss>'
    } 3>&1 >"$rssfile"
    echo ""

    mv "$rssfile" "$blog_feed"
    chmod 644 "$blog_feed"
}

# generate headers, footers, etc
create_includes() {
    #170821 BK change to an image banner...
    #{
    #    echo "<h1 class=\"nomargin\"><a class=\"ablack\" href=\"$global_cms_url/$index_file\">$global_title</a></h1>" 
    #    echo "<div id=\"description\">$global_description</div>"
    #} > ".title.html"
    
    #echo "<img src=\"images0/top-banner.png\" />" > ".title.html"
    css_style_container="columns is-multiline is-vcentered"
    css_style_banner_outer_container="column"
    css_style_banner_picture_container="column is-narrow is-vcentered ml-3 pb-0"
    css_style_banner_text_container="column is-narrow ml-3 pr-0 pb-0"
    banner_picture="sit-svgrepo-com.svg"
    css_style_figure_parameters="image is-128x128"
    css_style_title_size="is-size-2"
    echo "<div class=\"${css_style_container}\">" > ".title.html"    
    echo "<div class=\"${css_style_banner_picture_container}\">" >> ".title.html"
    echo "<figure class=\"${css_style_figure_parameters}\">" >> ".title.html"
    echo "<img src=\"images0/${banner_picture}\" />" >> ".title.html"
    echo "</figure></div>" >> ".title.html"
    echo "<div class=\"${css_style_banner_text_container}\">" >> ".title.html"
    #echo "<div class=\"content\">" >> ".title.html"
    echo "<h1 class=\"title is-size-2\"><strong>${global_title}</strong></h1>" >> ".title.html" 
    echo "<p class=\"subtitle\">${global_description}</p>" >> ".title.html" 
    #echo "</div>" >> ".title.html" #text container
    echo "</div></div>" >> ".title.html" #containers
    
    #170830a buttons below banner...
    echo '<div class="column is-narrow pt-0">' >> .title.html
    css_button_style="button is-primary is-light" #20230424 Added support for a css_button_style class for the headers.
    for NUM in 1 2 3 #permanent buttons, all pages.
    do
     eval "PERM=\$button_permanent_${NUM}" #implements indirection. ex: PERM=sitehome
     if [ "$PERM" ];then
      eval "button_url=\$button_${PERM}_url"
      eval "button_icon=\$button_${PERM}_icon"
      eval "button_tooltip=\$button_${PERM}_tooltip"
      eval "button_text=\$button_${PERM}_text"
      echo "<a class=\"${css_button_style}\" href=\"${button_url}\"><img src=\"images0/${button_icon}\" width=\"24\" height=\"24\" title=\"${button_tooltip}\" />${button_text}</a>&nbsp;" >> ".title.html"
     fi
    done
    echo "<!--SECONDBUTTON-->
        <!--THIRDBUTTON-->
        <!--FOURTHBUTTON-->
        <!--FIFTHBUTTON-->
        <!--SIXTHBUTTON-->
        <!--SEVENTHBUTTON-->
        </div><br />" >> ".title.html"

    cp -f "$header_file" .header.html
    cp -f "$footer_file" .footer.html
}

# Delete the temporarily generated include files
delete_includes() {
    rm ".title.html" ".footer.html" ".header.html"
}
rebuild_all_entries_interactive(){
    if (( INTERACTIVE && USE_GUM )); then
    gum spin --spinner dot --title "Building site‚Ä¶" -- \
        rebuild_all_entries
    else
        rebuild_all_entries
    fi

}


# Regenerates all the .html posts from the .htmraw posts
rebuild_all_entries() {
 local nameonly1
 echo -n "Rebuilding all entries "
 
 for i in ./*/*.htmraw; do
  nameonly0="${i/.htmraw/}" #includes sub-folder. ex: 201709/name-of-post
  nameonly1="${nameonly0#./}" #take off leading "./"
  subfoldername="${nameonly1%/*}" #ex: 201709
  
  echo -n "."
  if [ -f ${nameonly1}.html ];then
   timestamp0=$(awk '/<!-- '$date_inpost': .+ -->/ { print }' "${nameonly1}.html" | cut -d '#' -f 2)
   [[ -n $timestamp0 ]] && touch -t "$timestamp0" "${nameonly1}.html"
   timestamp1=$(LC_ALL=C date -r "${nameonly1}.html" +"$date_format_full")
   rm -f ${nameonly1}.html
  else
   timestamp0=$(LC_ALL=C date -r "${nameonly1}.htmraw" +"$date_format_timestamp")
   timestamp1=$(LC_ALL=C date -r "${nameonly1}.htmraw" +"$date_format_full")
  fi
  touch -t "$timestamp0" "${nameonly1}.htmraw"
  
  sed '1,/<body>/d;/<\/body>/Q' ${nameonly1}.htmraw > .tmpfile0 #leave only inside body tags.
  
  ln -snf ${subfoldername}/images images #temporary.
  parse_file_func .tmpfile0 "${timestamp1}" ${nameonly1}.html
  rm -f images

  touch -t "$timestamp0" "${nameonly1}.html"
  rm -f .tmpfile0
  
 done
 echo ""
}

# Delete all generated content
reset_func() {
    local confirm

    if (( INTERACTIVE )); then
        if (( USE_GUM )); then
            confirm=$(gum confirm "Are you sure you want to delete all posts?")
        else
            dialog --yesno "Are you sure you want to delete all posts?" 8 50
            confirm=$?
        fi

        if { (( USE_GUM )) && $confirm; } || { (( !USE_GUM )) && (( confirm == 0 )); }; then
            rm .*.html ./*.html ./*.css ./*.rss &> /dev/null
            for i in ./*/*.html ./*/*.htmraw; do
                [[ -d ${i%/*}/cms_config ]] && continue  # Skip nested shellCMS
                rm -f "$i"
            done
            echo
            echo "Deleted all posts, and feeds."
            echo "Kept your old '.backup.tar.gz' just in case, please delete it manually if needed."
        else
            echo "Phew! You dodged a bullet there. Nothing was modified."
        fi

    else
        echo "Are you sure you want to delete all posts? Please write \"Yes, I am!\""
        read -r line
        if [[ $line == "Yes, I am!" ]]; then
            rm .*.html ./*.html ./*.css ./*.rss &> /dev/null
            for i in ./*/*.html ./*/*.htmraw; do
                [[ -d ${i%/*}/cms_config ]] && continue
                rm -f "$i"
            done
            echo
            echo "Deleted all posts, and feeds."
            echo "Kept your old '.backup.tar.gz' just in case, please delete it manually if needed."
        else
            echo "Phew! You dodged a bullet there. Nothing was modified."
        fi
    fi
}

# Detects if GNU date is installed
date_version_detect() {
	date --version >/dev/null 2>&1
	if (($? != 0));  then
		# date utility is BSD. Test if gdate is installed 
		if gdate --version >/dev/null 2>&1 ; then
            date() {
                gdate "$@"
            }
		else
            # BSD date
            date() {
                if [[ $1 == -r ]]; then
                    # Fall back to using stat for 'date -r'
                    format=${3//+/}
                    stat -f "%Sm" -t "$format" "$2"
                elif [[ $2 == --date* ]]; then
                    # convert between dates using BSD date syntax
                    command date -j -f "$date_format_full" "${2#--date=}" "$1" 
                else
                    # acceptable format for BSD date
                    command date -j "$@"
                fi
            }
        fi
    fi    
}

# Main function
# Encapsulated on its own function for readability purposes
# $1  path
# $2  command to run
# $3  file name of a draft to continue editing (optional)
do_main() {
 # Detect if using BSD date or GNU date
 date_version_detect
 # Load default configuration, then override settings with the config file
 global_variables
 [[ -f $global_config ]] && source "$global_config" &> /dev/null 
 global_variables_check
 EDITOR="$EDITOR0" #20211201
 
 #20230421: fix  editor with switches(options) was not working properly because next validation, sanitizing the editor variable first
EDITORALL="$EDITOR"
EDITORNOOPT="${EDITORALL%% *}"
 #20230421

 if [ -x ${PWD0}/${EDITORNOOPT} ];then #ex: mozeditor
  EDITOREXE="${PWD0}/${EDITORALL}"
 else
  if which $EDITORNOOPT >/dev/null ; then
   EDITOREXE="$EDITORALL"
  else
   echo "EDITOR='${EDITOR}' PWD='${PWD}'"
   echo "EDITOR variable in 'config' file is invalid, aborting"
   exit 1
  fi
 fi

 # Check for validity of argument
 [[ $2 != "reset" && $2 != "post" && $2 != "rebuild" && $2 != "list" && $2 != "edit" && $2 != "delete" && $2 != "tags" ]] && 
  usage_func && exit

 [[ $2 == list ]] &&
   list_posts && exit

 [[ $2 == tags ]] &&
  list_tags "$@" && exit

 if [[ $2 == edit ]]; then
  if (($# < 3)) || [[ ! -f ${!#} ]]; then
   echo "Please enter a valid .htmraw file to edit"
   exit
  fi
 fi

if [[ "$2" == "post" ]]; then
  if [[ -n "$3" ]]; then
    [[ "${3##*.}" != "htmraw" ]] && err_exit "'${3}' is required to be .htmraw"

    if [[ "${3%%/*}" == "drafts" ]]; then
      [[ ! -f "./$3" ]] && err_exit "'./${3}' does not exist in 'drafts' folder"
    else
      if [[ -f "./$3" ]]; then
        echo
        echo "WARNING: file '${3}' already exists"
        echo "The 'post' command is for creating a new post. To edit an existing post,"
        echo "you must use the 'edit' command. If you want to keep going, and completely"
        echo "replace the existing file, confirm below."

        local overwrite_ok=0

        if (( INTERACTIVE )); then
          if (( USE_GUM )); then
            gum confirm "Replace '${3}'? This will delete its current content." && overwrite_ok=1
          else
            dialog --yesno "File '${3}' already exists.\nDo you want to overwrite it?" 10 60
            (( $? == 0 )) && overwrite_ok=1
          fi
        else
          echo -n "Press 'y' then ENTER to confirm, anything else to cancel: "
          read -r yourresponse
          [[ "$yourresponse" == "y" ]] && overwrite_ok=1
        fi

        (( !overwrite_ok )) && exit 1
      fi
    fi
  fi
fi

 [[ $2 == reset ]] && reset_func && exit

 create_includes
 [[ $2 == post ]] && write_entry_func $@
 [[ $2 == rebuild ]] && rebuild_all_entries_interactive && rebuild_tags
 if [[ $2 == delete ]];then
  nameonly="$(basename ${3} | cut -f 1 -d '.')"
  echo "Deleting: ${nameonly}.html and .htmraw"
  rm ./*/${3}.* &> /dev/null && rebuild_tags
 fi
 if [[ $2 == edit ]]; then
  if [[ $3 == -n ]]; then
   edit_func "$4"
  else
   edit_func "$3" keep
  fi
 fi
 rebuild_index
 all_posts
 all_tags
 all_docs_func
 #[ "$MODE" == "document" ] && ln -snf $docs_index $index_file
 [ "$MODE" == "document" ] && mv -f $docs_index $index_file
 make_rss
 delete_includes
}


# MAIN

if (( INTERACTIVE )); then
  # ‚Äî‚Äî Prompt for path ‚Äî‚Äî
  if (( USE_GUM )); then
    SHELLCMS_PATH=$(gum input --placeholder "shellCMS path" --value "www/news")
  else
    SHELLCMS_PATH=$(dialog --stdout --inputbox "Path to shellCMS:" 0 0 "www/news")
  fi
  (( $? != 0 )) && exit

  # ‚Äî‚Äî Prompt for command ‚Äî‚Äî
  if (( USE_GUM )); then
    CMD=$(gum choose post edit delete rebuild reset list tags)
  else
    CMD=$(dialog --stdout \
      --menu "Choose command:" 0 0 0 \
      post    "New post / continue draft" \
      edit    "Edit existing post" \
      delete  "Delete a post" \
      rebuild "Rebuild site" \
      reset   "Delete all posts" \
      list    "List posts" \
      tags    "List tags")
  fi
  [[ -z $CMD ]] && exit

  # ‚Äî‚Äî If the command needs a filename ‚Äî‚Äî
  ARGS=( "$SHELLCMS_PATH" "$CMD" )
  if [[ "$CMD" =~ ^(edit|delete)$ ]]; then
    if (( USE_GUM )); then
      TARGET=$(gum input --placeholder "folder/filename" --value "${CMD}/new-post.htmraw")
    else
      TARGET=$(dialog --stdout \
        --inputbox "Enter folder/filename for '$CMD':" 0 0 "${CMD}/new-post.htmraw")
    fi
    (( $? != 0 )) && exit
    ARGS+=( "$TARGET" )
  fi

  # ‚Äî‚Äî Finally invoke do_main with our rebuilt args ‚Äî‚Äî
  do_initial_setup "${ARGS[@]}"
  do_main "${ARGS[@]}"

else
  # non‚Äëinteractive: just pass everything straight through
  do_initial_setup "$@"
  do_main "$@"
fi
###end###
